# Ch1 预备知识

## typedef

### typedef 不能提供类型安全

    class Person
    {
    public:
        typedef double Inches;
        typedef double Pounds;
    public:
        Person();
        void SetWeight(Pounds weight);
        void getHeight(Inches height);
    };
    
    void f (const Person& person){
    Person::Inches height = person.getHeight();
    person.SetWeight(height); // 这里不会因为 height 的类型不是 Pounds 而报错
}

### typedef 的用途

* 声明复杂的类型
    
    typedef int (Person::*PCPMFDI)(double) const; // 声明一个指针类型，
                                                  // 指向 const person 成员函数
                                                  // 参数类型为 double
                                                  // 返回类型为 int
                                                 

## Assert

开发工作完成后，设置preprocess 预处理 NDEBUG，可以将所有的 assert 语句都去掉。
注意：assert 中应该只判断不要操作对象。

    class String
    {
    public:
        enum {DEFAULT_SIZE = 8};
        char *d_array_p;
        int d_size;
        int d_length;
    public:
        String();
    };
    
    String::String()
    {
        assert(d_array_p = new char[d_size]); // 错误： assert 中应该只判断
                                              // 不要操作对象，否则会使 prod
                                              // 的版本和 debug 的版本行为不
                                              // 同。因为 prod 版 用 NDEBUG
                                              // 去掉了所有 assert.
    

        // 可以这样写
        d_array_p = new char[d_size];
        assert(d_array_p);
     }
     


## Coding style 编码风格
 
### Variable member 的命名
 
 * variable member 加统一前缀 比如 \_d, （\_d 代表 dynamic 吧，总在变化）
 * variable member 后缀 \_p 代表该 member 是一个 pointer
 * \_s 表示 static variable member, static member 放在 .c 文件中
 * 类内 const member DEFAULT_VALUE
 * 类内 static const member S_DEFAULT_VALUE
 
 其他知识点：
 类 member variable 代表对象的状态，改变他们，就是改变对象的状态
 
 ### 类的 method member 的排列顺序
 
 按照功能排列 methods, 如示例代码, 每组将methods 按字母顺序排列
 
        class Car
        {
            // 按照功能排列 methods
         public:
            // CREATORS 生成和取消对象 
            Car(int cost = 0);
            Car(const Car& car );
            ~Car();

            // MANIPULATION 就是 non const method members 
            // 将methods 按字母顺序排列
            Car& operator=(const Car& car);
            void addFuel(double numberOfGallons);
            void drive(double deltaGasPedal);
            void turn(double angleInDegree);

            // ACCESSORS 都是 const method members
            double getFuel() const;
            double getRPMs() const;
            double getSpeed() const;
        };
不要将 getXXX() setXXX() 排在一起。这样容易暴露 XXX（variable member）的行为。

* 为了隐藏 implementation,  variable member 最好不出现在 .h 文件中   
 
